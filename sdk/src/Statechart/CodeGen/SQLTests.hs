-- | This module contains functions for going from charts to sql files.
-- Eventually it should be done with pretty printers to make it more robust (also pretty)
module Statechart.CodeGen.SQLTests (mkTest, genTest, writeSQLTests) where

import Data.String.Interpolate
import Data.Text as T
import RIO
import Statechart.Helpers
import Statechart.Types

------------
-- PUBLIC --
------------

mkTest :: Text -> Text -> Chart StateName EventName -> SQLTest
mkTest chartname schema Chart{..} =
    let initial_ = toText initial
        actions = [] -- TODO this is wrong toText <$> getEventNames Chart{..}
        tests = transitionTest Chart{..} <$> getAllChartTransitions Chart{..}
    in SQLTest{..}

genTest :: SQLTest -> Text
genTest SQLTest{..} =
    let pn = planNumber SQLTest{..}
        fnChecks = T.unlines (fnCheck schema <$> actions)
        interceptions' = T.unlines (genInterception schema <$> actions)
        transitions = T.unlines (genTransitionTest initial_ <$> tests)
     in sqlTestLayout pn fnChecks interceptions' transitions

writeSQLTests :: FilePath -> [Text] -> IO ()
writeSQLTests path xs =
    undefined -- foldM go  xs
 where
    go a acc = undefined
    -- TODO remember that file name should end in ".pg"
    -- TODO just build correct file name here

-------------
-- HELPERS --
-------------

transitionTest :: Chart StateName EventName -> Transition StateName EventName -> IndividualTest
transitionTest chart t =
    let source_ = toText (source t)
        transition = toText (event' t)
        target_ = toText (target t)
        on_entry =
          case lookupState chart (source t) of -- <$> getStateNames chart
            Nothing -> []
            Just s -> case onEntry s of
                        Nothing -> []
                        Just (Script oe) -> [oe]
     in IndividualTest{..}

data SQLTest = SQLTest
    { chartname :: Text
    , schema :: Text
    , initial_ :: Text
    , actions :: [Text]
    , tests :: [IndividualTest]
    }

data IndividualTest = IndividualTest
    { source_ :: Text
    , transition :: Text
    , target_ :: Text
    , on_entry :: [Text]
    }

-- | The total number of tests we intended to run.
planNumber :: SQLTest -> Text
planNumber SQLTest{..} = T.pack (show (RIO.length actions + RIO.length tests))

-- | The main layout for the SQL test file.
sqlTestLayout :: Text -> Text -> Text -> Text -> Text -- FIXME this is a shitty type
sqlTestLayout pn fnChecks interceptions' transitions =
    [i|
-----------------------------------------------------------------------------------------------
--                                                                                           --
--                                        -----------                                        --
--                                        - WARNING -                                        --
--                                        -----------                                        --
--                                                                                           --
--                                            ***                                            --
--                                                                                           --
--                                   DO NOT EDIT THIS FILE                                   --
--                               IT WAS AUTOMATICALLY GENERATED                              --
--                                CHANGES MAY BE OVERWRITTEN                                 --
--                                                                                           --
--                                            ***                                            --
--                                                                                           --
-----------------------------------------------------------------------------------------------
BEGIN;
select plan(#{pn}); -- (PG_TAP function)
\\i statecharts/test/setup_helpers.sql
-----------------------------------------------------------------------------------------------
-- FUNCTION CHECKS ----------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
#{fnChecks}
-----------------------------------------------------------------------------------------------
-- INTERCEPTIONS ------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
#{interceptions'}
-----------------------------------------------------------------------------------------------
-- TRANSITIONS TESTS --------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
#{transitions}
-----------------------------------------------------------------------------------------------
-- FINISHING ----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
select finish(); -- (PG_TAP function)
ROLLBACK;
-----------------------------------------------------------------------------------------------
-- END ----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
|]

-- | This add static checks for the action functions. Mostly a courtesy.
fnCheck :: Text -> Text -> Text
fnCheck schema fn = [iii| select is(function_exists('#{schema}','#{fn}'), true, '#{fn}'); |]

-- | Used to generate a new definition of the action function so we can intercept its instead of letting it run.
genInterception :: Text -> Text -> Text
genInterception schema fn =
    [i|
create or replace function #{schema}.#{fn}(event_payload fsm_event_payload) returns void as
$$ begin perform intercepted_('#{schema}.#{fn}); return; end; $$ language plpgsql volatile strict;
|]

-- | We use this to generate the each cluster of a transition test, which includes several lines.
genTransitionTest :: Text -> IndividualTest -> Text
genTransitionTest initial' IndividualTest{..} =
    T.unlines (catMaybes $ [Just starter, setter, Just notifier, Just statechecker] <> actioncheckers)
  where
    starter :: Text
    starter = "select id as mid from fsm.start_machine_with_latest_statechart(:shard,:chartname) \\gset"
    setter :: Maybe Text
    setter = if target_ == initial' then Nothing else Just [iii| empty |] -- TODO
    notifier :: Text
    notifier = [iii|select fsm.notify_state_machine(1,:mid,'#{transition}');|]
    statechecker :: Text
    statechecker = [iii|select is((select fsm.is_state_active(1,:mid,#{initial'})),true, 'state is #{initial'}');|]
    actioncheckers :: [Maybe Text]
    actioncheckers =
        go <$> on_entry
      where
        go action = Just [iii|select is((select last_intercepted()),'#{action}');|]
