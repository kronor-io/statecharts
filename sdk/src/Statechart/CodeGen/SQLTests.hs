-- | This module contains functions for going from charts to sql files.
-- Eventually it should be done with pretty printers to make it more robust (also pretty)
module Statechart.CodeGen.SQLTests (mkTest, genTest) where

import Data.String.Interpolate
import Data.Text as T
import RIO
import Statechart.Types

------------
-- PUBLIC --
------------

mkTest :: Chart StateName EventName -> SQLTest
mkTest = undefined

genTest :: SQLTest -> Text
genTest SQLTest{..} =
    let pn = planNumber SQLTest{..}
        schema = undefined SQLTest{..}
        fnChecks = T.unlines (fnCheck schema <$> []) -- TODO
        interceptions' = T.unlines (genInterception schema <$> []) -- TODO
        transitions = T.unlines (genTransitionTest <$> []) -- TODO
     in layout pn fnChecks interceptions' transitions

-------------
-- HELPERS --
-------------

data SQLTest = SQLTest
    { chartname :: Text
    , actions :: [Text]
    , interceptions :: [Text]
    , tests :: [IndividualTest]
    }

data IndividualTest = IndividualTest
    { source :: Text
    , transname :: Text
    , target :: Text
    , on_entry :: [Text]
    }

-- | The total number of tests we intended to run.
planNumber :: SQLTest -> Text
planNumber SQLTest{..} = T.pack (show (RIO.length actions + RIO.length tests))

-- | The main layout for the SQL test file.
layout :: Text -> Text -> Text -> Text -> Text
layout pn fnChecks interceptions' transitions =
    [i|
-----------------------------------------------------------------------------------------------
--                                                                                           --
--                                        -----------                                        --
--                                        - WARNING -                                        --
--                                        -----------                                        --
--                                                                                           --
--                                            ***                                            --
--                                                                                           --
--                                   DO NOT EDIT THIS FILE                                   --
--                               IT WAS AUTOMATICALLY GENERATED                              --
--                                CHANGES MAY BE OVERWRITTEN                                 --
--                                                                                           --
--                                            ***                                            --
--                                                                                           --
-----------------------------------------------------------------------------------------------
-- CHART NAME            :                                                                   --
-- CHART VERSION         :                                                                   --
-- NUMBER OF STATES      :                                                                   --
-- NUMBER OF TRANSITIONS :                                                                   --
-- NUMBER OF ACTIONS     :                                                                   --
-----------------------------------------------------------------------------------------------
BEGIN;
select plan(#{pn}); -- (PG_TAP function)
-----------------------------------------------------------------------------------------------
-- FUNCTION CHECKS ----------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
#{fnChecks}
-----------------------------------------------------------------------------------------------
-- INTERCEPTIONS ------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
#{interceptions'}
-----------------------------------------------------------------------------------------------
-- TRANSITIONS TESTS --------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
#{transitions}
-----------------------------------------------------------------------------------------------
-- FINISHING ----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
select finish(); -- (PG_TAP function)
ROLLBACK;
-----------------------------------------------------------------------------------------------
-- END ---------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
|]

-- | This add static checks for the action functions. Mostly a courtesy.
fnCheck :: Text -> Text -> Text
fnCheck schema fn = [iii| select is(function_exists('#{schema}','#{fn}'), true, '#{fn}'); |]

-- | Used to generate a new definition of the action function so we can intercept its instead of letting it run.
genInterception :: Text -> Text -> Text
genInterception schema fn =
    [i|
create or replace function #{schema}.#{fn}(event_payload fsm_event_payload) returns void as
$$ begin perform intercepted_('#{schema}.#{fn}); return; end; $$ language plpgsql volatile strict;
|]

-- | We use this to generate the each cluster of a transition test, which includes several lines.
genTransitionTest :: IndividualTest -> Text
genTransitionTest IndividualTest{..} =
    T.unlines (catMaybes [Just starter, setter, Just notifier, Just statechecker, actionchecker])
  where
    starter :: Text
    starter = [iii| select id as mid from fsm.start_machine_with_latest_statechart(:shard,:chartname) \\gset |]
    setter :: Maybe Text
    setter = undefined -- TODO setter fires fore everything, except the first item
    notifier :: Text
    notifier = [iii| ... |]
    statechecker :: Text
    statechecker = [iii| ... |]
    actionchecker :: Maybe Text
    actionchecker = undefined -- the one that is most uncertain

--smallest one, typical (we just check the initial state, basically)
--select id as mid from fsm.start_machine_with_latest_statechart(:shard,:chartname) \gset
--select is((select fsm.is_state_active(:shard,:mid,:initial)),true, 'state is created');

--small one
--select id as mid from fsm.start_machine_with_latest_statechart(:shard,:chartname) \gset
--select is((select fsm.is_state_active(:shard,:mid,:initial)),true, 'state is created');
--select is((select last_intercepted()),'invoice.created_action');

-- medium boy
--update fsm.state_machine_state SET state_id = 'in_progress_soft_reminder' where state_machine_id = :mid and shard_id = :shard and state_id = :initial;
--select fsm.notify_state_machine(:shard,:mid,'invoice.time.due');
--select is((select fsm.is_state_active(:shard,:mid,'due_date')),true, 'state is due_date');
--select is((select last_intercepted()),'invoice.due_date_action');

-- big boy
--select id as mid from fsm.start_machine_with_latest_statechart(:shard,:chartname) \gset
--update fsm.state_machine_state SET state_id = 'reminder1' where state_machine_id = :mid and shard_id = :shard and state_id = :initial;
--select fsm.notify_state_machine(:shard,:mid,'invoice.time.reminder2');
--select is((select fsm.is_state_active(:shard,:mid,'reminder2')),true, 'state is reminder2');
--select is((select last_intercepted()),'invoice.reminder2_action');
