-- | This module contains functions for going from charts to sql files.
-- Eventually it should be done with pretty printers to make it more robust (also pretty)
module Statechart.CodeGen.SQLTests (mkTest, genTest, writeSQLTests) where

import Data.String.Interpolate
import Data.Text as T
import RIO
import RIO.ByteString qualified as BS
import RIO.List (sort)
import Statechart.Helpers
import Statechart.Types
import System.FilePath.Posix

------------
-- PUBLIC --
------------

mkTest :: Text -> Chart StateName EventName -> SQLTest
mkTest chartname Chart{..} =
    let initial_ = toText initial
        actions = toText <$> getAllActions Chart{..}
        tests = transitionTest Chart{..} <$> getAllChartTransitions Chart{..}
     in SQLTest{..}

genTest :: Chart StateName EventName -> SQLTest -> Text
genTest chart SQLTest{..} =
    let pn = planNumber SQLTest{..}
        fnChecks = T.unlines . sort $ (fnCheck <$> actions)
        interceptions' = T.unlines . sort $ (genInterception <$> actions)
        transitions = T.unlines . sort $ (genTransitionTest chart chartname <$> tests)
     in sqlTestLayout pn fnChecks interceptions' transitions

writeSQLTests :: FilePath -> [(Text, Text)] -> IO ()
writeSQLTests path xs = do
    let finalpath p = path <> "/" <> dropExtensions (T.unpack p) <> ".pg"
    forM_ xs (\(p, bod) -> BS.writeFile (finalpath p) (RIO.encodeUtf8 bod))

-------------
-- HELPERS --
-------------

transitionTest :: Chart StateName EventName -> Transition StateName EventName -> IndividualTest
transitionTest chart t =
    let source_ = toText (source t)
        transition = toText (event' t)
        target_ = toText (target t)
        on_entry =
            case lookupState chart (target t) of -- <$> getStateNames chart
                Nothing -> []
                Just s -> case onEntry s of
                    Nothing -> []
                    Just (Script oe) -> [oe]
     in IndividualTest{..}

data SQLTest = SQLTest
    { chartname :: Text
    , initial_ :: Text
    , actions :: [Text]
    , tests :: [IndividualTest]
    }

data IndividualTest = IndividualTest
    { source_ :: Text
    , transition :: Text
    , target_ :: Text
    , on_entry :: [Text]
    }

-- | The total number of tests we intended to run.
planNumber :: SQLTest -> Text
planNumber SQLTest{..} = T.pack (show (RIO.length actions + RIO.length tests))

-- | The main layout for the SQL test file.
sqlTestLayout :: Text -> Text -> Text -> Text -> Text -- FIXME this is a shitty type
sqlTestLayout pn fnChecks interceptions' transitions =
    [i|
-----------------------------------------------------------------------------------------------
--                                                                                           --
--                                        -----------                                        --
--                                        - WARNING -                                        --
--                                        -----------                                        --
--                                                                                           --
--                                            ***                                            --
--                                                                                           --
--                                   DO NOT EDIT THIS FILE                                   --
--                               IT WAS AUTOMATICALLY GENERATED                              --
--                                CHANGES MAY BE OVERWRITTEN                                 --
--                                                                                           --
--                                            ***                                            --
--                                                                                           --
-----------------------------------------------------------------------------------------------
BEGIN;
select plan(#{pn}); -- (PG_TAP function)
\\i statecharts/test/setup_helpers.sql
-----------------------------------------------------------------------------------------------
-- FUNCTION CHECKS ----------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
#{fnChecks}
-----------------------------------------------------------------------------------------------
-- INTERCEPTIONS ------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
#{interceptions'}
-----------------------------------------------------------------------------------------------
-- TRANSITIONS TESTS --------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
#{transitions}
-----------------------------------------------------------------------------------------------
-- FINISHING ----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
select finish(); -- (PG_TAP function)
ROLLBACK;
-----------------------------------------------------------------------------------------------
-- END ----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
|]

-- | Used to generate a new definition of the action function so we can intercept its instead of letting it run.
genInterception :: Text -> Text
genInterception dat =
    let [schema, fn] = T.splitOn "." dat
     in [iii|
create or replace function #{schema}.#{fn}(event_payload fsm_event_payload) returns void as
$$ begin perform intercepted_('#{schema}.#{fn}'); return; end; $$ language plpgsql volatile strict;
|]

-- | We use this to generate the each cluster of a transition test, which includes several lines.
genTransitionTest :: Chart StateName EventName -> Text -> IndividualTest -> Text
genTransitionTest chart chartname IndividualTest{..} =
    T.unlines (catMaybes $ [Just starter, setter, Just notifier, Just statechecker] <> actioncheckers <> [Just ""])
  where
    starter :: Text
    starter =
        let sanitized = dropExtensions (T.unpack chartname)
         in [i|select id as mid from fsm.start_machine_with_latest_statechart(1,'#{sanitized}') \\gset|]
    setter :: Maybe Text
    setter =
        let ss = lookupState chart (StateName source_)
         in case ss of
                Nothing -> Nothing
                Just s ->
                    if isInitial chart s
                        then Nothing -- error . show $ (source_,initial')
                        else
                            let (StateName l) = initial chart
                             in Just [iii| update fsm.state_machine_state SET state_id = '#{source_}' where state_machine_id = :mid and shard_id = 1 and state_id = '#{l}'; |]
    notifier :: Text
    notifier = [iii|select fsm.notify_state_machine(1,:mid,'#{transition}');|]
    statechecker :: Text
    statechecker = [iii|select is((select fsm.is_state_active(1,:mid,'#{target_}')),true);|]
    actioncheckers :: [Maybe Text]
    actioncheckers =
        go <$> on_entry
      where
        go action = Just [iii|select is((select last_intercepted()),'#{action}');|]

-- | This add static checks for the action functions. Mostly a courtesy.
fnCheck :: Text -> Text
fnCheck dat =
    let [schema, fn] = T.splitOn "." dat
     in [iii|select is(function_exists('#{schema}','#{fn}'), true);|]
