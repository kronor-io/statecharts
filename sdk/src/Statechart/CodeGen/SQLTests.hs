-- | This module contains functions for going from charts to sql files.
-- Eventually it should be done with pretty printers to make it more robust (also pretty)
module Statechart.CodeGen.SQLTests (mkTest, genTest) where

import Data.String.Interpolate
import Data.Text as T
import RIO
import Statechart.Types

------------
-- PUBLIC --
------------

mkTest :: Chart StateName EventName -> SQLTest
mkTest = undefined -- TODO

genTest :: SQLTest -> Text
genTest SQLTest{..} =
    let pn = planNumber SQLTest{..}
        fnChecks = T.unlines (fnCheck schema <$> actions)
        interceptions' = T.unlines (genInterception schema <$> interceptions)
        transitions = T.unlines (genTransitionTest initial <$> tests)
     in layout pn fnChecks interceptions' transitions

-------------
-- HELPERS --
-------------

data SQLTest = SQLTest
    { chartname :: Text
    , schema :: Text
    , initial :: Text
    , actions :: [Text]
    , interceptions :: [Text]
    , tests :: [IndividualTest]
    }

data IndividualTest = IndividualTest
    { source :: Text
    , transition :: Text
    , target :: Text
    , on_entry :: [Text]
    }

-- | The total number of tests we intended to run.
planNumber :: SQLTest -> Text
planNumber SQLTest{..} = T.pack (show (RIO.length actions + RIO.length tests))

-- | The main layout for the SQL test file.
layout :: Text -> Text -> Text -> Text -> Text
layout pn fnChecks interceptions' transitions =
    [i|
-----------------------------------------------------------------------------------------------
--                                                                                           --
--                                        -----------                                        --
--                                        - WARNING -                                        --
--                                        -----------                                        --
--                                                                                           --
--                                            ***                                            --
--                                                                                           --
--                                   DO NOT EDIT THIS FILE                                   --
--                               IT WAS AUTOMATICALLY GENERATED                              --
--                                CHANGES MAY BE OVERWRITTEN                                 --
--                                                                                           --
--                                            ***                                            --
--                                                                                           --
-----------------------------------------------------------------------------------------------
-- CHART NAME            :                                                                   --
-- CHART VERSION         :                                                                   --
-- NUMBER OF STATES      :                                                                   --
-- NUMBER OF TRANSITIONS :                                                                   --
-- NUMBER OF ACTIONS     :                                                                   --
-----------------------------------------------------------------------------------------------
BEGIN;
select plan(#{pn}); -- (PG_TAP function)
-----------------------------------------------------------------------------------------------
-- FUNCTION CHECKS ----------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
#{fnChecks}
-----------------------------------------------------------------------------------------------
-- INTERCEPTIONS ------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
#{interceptions'}
-----------------------------------------------------------------------------------------------
-- TRANSITIONS TESTS --------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
#{transitions}
-----------------------------------------------------------------------------------------------
-- FINISHING ----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
select finish(); -- (PG_TAP function)
ROLLBACK;
-----------------------------------------------------------------------------------------------
-- END ---------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
|]

-- | This add static checks for the action functions. Mostly a courtesy.
fnCheck :: Text -> Text -> Text
fnCheck schema fn = [iii| select is(function_exists('#{schema}','#{fn}'), true, '#{fn}'); |]

-- | Used to generate a new definition of the action function so we can intercept its instead of letting it run.
genInterception :: Text -> Text -> Text
genInterception schema fn =
    [i|
create or replace function #{schema}.#{fn}(event_payload fsm_event_payload) returns void as
$$ begin perform intercepted_('#{schema}.#{fn}); return; end; $$ language plpgsql volatile strict;
|]

-- | We use this to generate the each cluster of a transition test, which includes several lines.
genTransitionTest :: Text -> IndividualTest -> Text
genTransitionTest initial IndividualTest{..} =
    T.unlines (catMaybes $ [Just starter, setter, Just notifier, Just statechecker] <> actioncheckers)
  where
    starter :: Text
    starter = [iii| select id as mid from fsm.start_machine_with_latest_statechart(:shard,:chartname) \\gset |]
    setter :: Maybe Text
    setter = if target == initial then Nothing else Just [iii||]
    notifier :: Text
    notifier = [iii|select fsm.notify_state_machine(1,:mid,'#{transition}');|]
    statechecker :: Text
    statechecker = [iii|select is((select fsm.is_state_active(1,:mid,#{initial})),true, 'state is #{initial}');|]
    actioncheckers :: [Maybe Text]
    actioncheckers =
      go =<< on_entry
     where
       go action =
        [ Just [iii|select is((select last_intercepted()),'#{action}');|]
        ]
